{"message":"unused `#[macro_use]` import","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/lib.rs","byte_start":145,"byte_end":157,"line_start":6,"line_end":6,"column_start":1,"column_end":13,"is_primary":true,"text":[{"text":"#[macro_use]","highlight_start":1,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused `#[macro_use]` import\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:6:1\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m6\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m#[macro_use]\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_imports)]` on by default\u001b[0m\n\n"}
{"message":"unused import: `failure::Error`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/errors.rs","byte_start":4,"byte_end":18,"line_start":1,"line_end":1,"column_start":5,"column_end":19,"is_primary":true,"text":[{"text":"use failure::Error;","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/errors.rs","byte_start":0,"byte_end":19,"line_start":1,"line_end":1,"column_start":1,"column_end":20,"is_primary":true,"text":[{"text":"use failure::Error;","highlight_start":1,"highlight_end":20}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `failure::Error`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/errors.rs:1:5\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0muse failure::Error;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"unused imports: `G1Vector`, `G1`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/pok_sig.rs","byte_start":378,"byte_end":386,"line_start":9,"line_end":9,"column_start":35,"column_end":43,"is_primary":true,"text":[{"text":"use amcl_wrapper::group_elem_g1::{G1Vector, G1};","highlight_start":35,"highlight_end":43}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/pok_sig.rs","byte_start":388,"byte_end":390,"line_start":9,"line_end":9,"column_start":45,"column_end":47,"is_primary":true,"text":[{"text":"use amcl_wrapper::group_elem_g1::{G1Vector, G1};","highlight_start":45,"highlight_end":47}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/pok_sig.rs","byte_start":344,"byte_end":392,"line_start":9,"line_end":9,"column_start":1,"column_end":49,"is_primary":true,"text":[{"text":"use amcl_wrapper::group_elem_g1::{G1Vector, G1};","highlight_start":1,"highlight_end":49}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused imports: `G1Vector`, `G1`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/pok_sig.rs:9:35\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m9\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0muse amcl_wrapper::group_elem_g1::{G1Vector, G1};\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^\u001b[0m\n\n"}
{"message":"unused imports: `G2Vector`, `G2`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/pok_sig.rs","byte_start":427,"byte_end":435,"line_start":10,"line_end":10,"column_start":35,"column_end":43,"is_primary":true,"text":[{"text":"use amcl_wrapper::group_elem_g2::{G2Vector, G2};","highlight_start":35,"highlight_end":43}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/pok_sig.rs","byte_start":437,"byte_end":439,"line_start":10,"line_end":10,"column_start":45,"column_end":47,"is_primary":true,"text":[{"text":"use amcl_wrapper::group_elem_g2::{G2Vector, G2};","highlight_start":45,"highlight_end":47}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/pok_sig.rs","byte_start":393,"byte_end":441,"line_start":10,"line_end":10,"column_start":1,"column_end":49,"is_primary":true,"text":[{"text":"use amcl_wrapper::group_elem_g2::{G2Vector, G2};","highlight_start":1,"highlight_end":49}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused imports: `G2Vector`, `G2`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/pok_sig.rs:10:35\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m10\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0muse amcl_wrapper::group_elem_g2::{G2Vector, G2};\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^\u001b[0m\n\n"}
{"message":"unused import: `OtherGroup`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/signature.rs","byte_start":147,"byte_end":157,"line_start":4,"line_end":4,"column_start":28,"column_end":38,"is_primary":true,"text":[{"text":"use crate::{ate_2_pairing, OtherGroup, OtherGroupVec, SignatureGroup, SignatureGroupVec};","highlight_start":28,"highlight_end":38}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/signature.rs","byte_start":145,"byte_end":157,"line_start":4,"line_end":4,"column_start":26,"column_end":38,"is_primary":true,"text":[{"text":"use crate::{ate_2_pairing, OtherGroup, OtherGroupVec, SignatureGroup, SignatureGroupVec};","highlight_start":26,"highlight_end":38}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `OtherGroup`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/signature.rs:4:28\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0muse crate::{ate_2_pairing, OtherGroup, OtherGroupVec, SignatureGroup, SignatureGroupVec};\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^\u001b[0m\n\n"}
{"message":"`&FieldElementVector` is not an iterator","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/pok_vc.rs","byte_start":2046,"byte_end":2061,"line_start":56,"line_end":56,"column_start":50,"column_end":65,"is_primary":true,"text":[{"text":"                    .multi_scalar_mul_const_time(&self.blindings)","highlight_start":50,"highlight_end":65}],"label":"`&FieldElementVector` is not an iterator","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/pok_sig.rs","byte_start":599,"byte_end":753,"line_start":15,"line_end":21,"column_start":1,"column_end":3,"is_primary":false,"text":[{"text":"impl_PoK_VC!(","highlight_start":1,"highlight_end":14},{"text":"    ProverCommittingSignatureGroup,","highlight_start":1,"highlight_end":36},{"text":"    ProverCommittedSignatureGroup,","highlight_start":1,"highlight_end":35},{"text":"    ProofSignatureGroup,","highlight_start":1,"highlight_end":25},{"text":"    SignatureGroup,","highlight_start":1,"highlight_end":20},{"text":"    SignatureGroupVec","highlight_start":1,"highlight_end":22},{"text":");","highlight_start":1,"highlight_end":3}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_PoK_VC!","def_site_span":{"file_name":"src/pok_vc.rs","byte_start":60,"byte_end":5692,"line_start":4,"line_end":144,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! impl_PoK_VC {","highlight_start":1,"highlight_end":27},{"text":"    ( $ProverCommitting:ident, $ProverCommitted:ident, $Proof:ident, $group_element:ident, $group_element_vec:ident ) => {","highlight_start":1,"highlight_end":123},{"text":"        /// Proof of knowledge of messages in a vector commitment.","highlight_start":1,"highlight_end":67},{"text":"        /// Commit for each message.","highlight_start":1,"highlight_end":37},{"text":"        #[derive(Clone, Debug, Serialize, Deserialize)]","highlight_start":1,"highlight_end":56},{"text":"        pub struct $ProverCommitting {","highlight_start":1,"highlight_end":39},{"text":"            gens: $group_element_vec,","highlight_start":1,"highlight_end":38},{"text":"            blindings: FieldElementVector,","highlight_start":1,"highlight_end":43},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Receive or generate challenge. Compute response and proof","highlight_start":1,"highlight_end":70},{"text":"        #[derive(Clone, Debug, Serialize, Deserialize)]","highlight_start":1,"highlight_end":56},{"text":"        pub struct $ProverCommitted {","highlight_start":1,"highlight_end":38},{"text":"            gens: $group_element_vec,","highlight_start":1,"highlight_end":38},{"text":"            blindings: FieldElementVector,","highlight_start":1,"highlight_end":43},{"text":"            commitment: $group_element,","highlight_start":1,"highlight_end":40},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        #[derive(Clone, Debug, Serialize, Deserialize)]","highlight_start":1,"highlight_end":56},{"text":"        pub struct $Proof {","highlight_start":1,"highlight_end":28},{"text":"            pub commitment: $group_element,","highlight_start":1,"highlight_end":44},{"text":"            pub responses: FieldElementVector,","highlight_start":1,"highlight_end":47},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl $ProverCommitting {","highlight_start":1,"highlight_end":33},{"text":"            pub fn new() -> Self {","highlight_start":1,"highlight_end":35},{"text":"                Self {","highlight_start":1,"highlight_end":23},{"text":"                    gens: $group_element_vec::new(0),","highlight_start":1,"highlight_end":54},{"text":"                    blindings: FieldElementVector::new(0),","highlight_start":1,"highlight_end":59},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// generate a new random blinding if None provided","highlight_start":1,"highlight_end":64},{"text":"            pub fn commit(","highlight_start":1,"highlight_end":27},{"text":"                &mut self,","highlight_start":1,"highlight_end":27},{"text":"                gen: &$group_element,","highlight_start":1,"highlight_end":38},{"text":"                blinding: Option<&FieldElement>,","highlight_start":1,"highlight_end":49},{"text":"            ) -> usize {","highlight_start":1,"highlight_end":25},{"text":"                let blinding = match blinding {","highlight_start":1,"highlight_end":48},{"text":"                    Some(b) => b.clone(),","highlight_start":1,"highlight_end":42},{"text":"                    None => FieldElement::random(),","highlight_start":1,"highlight_end":52},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let idx = self.gens.len();","highlight_start":1,"highlight_end":43},{"text":"                self.gens.push(gen.clone());","highlight_start":1,"highlight_end":45},{"text":"                self.blindings.push(blinding);","highlight_start":1,"highlight_end":47},{"text":"                idx","highlight_start":1,"highlight_end":20},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Add pairwise product of (`self.gens`, self.blindings). Uses multi-exponentiation.","highlight_start":1,"highlight_end":98},{"text":"            pub fn finish(self) -> $ProverCommitted {","highlight_start":1,"highlight_end":54},{"text":"                let commitment = self","highlight_start":1,"highlight_end":38},{"text":"                    .gens","highlight_start":1,"highlight_end":26},{"text":"                    .multi_scalar_mul_const_time(&self.blindings)","highlight_start":1,"highlight_end":66},{"text":"                    .unwrap();","highlight_start":1,"highlight_end":31},{"text":"                $ProverCommitted {","highlight_start":1,"highlight_end":35},{"text":"                    gens: self.gens,","highlight_start":1,"highlight_end":37},{"text":"                    blindings: self.blindings,","highlight_start":1,"highlight_end":47},{"text":"                    commitment,","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn get_index(","highlight_start":1,"highlight_end":30},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                idx: usize,","highlight_start":1,"highlight_end":28},{"text":"            ) -> Result<(&$group_element, &FieldElement), PSError> {","highlight_start":1,"highlight_end":69},{"text":"                if idx >= self.gens.len() {","highlight_start":1,"highlight_end":44},{"text":"                    return Err(PSError::GeneralError {","highlight_start":1,"highlight_end":55},{"text":"                        msg: format!(\"index {} greater than size {}\", idx, self.gens.len()),","highlight_start":1,"highlight_end":93},{"text":"                    });","highlight_start":1,"highlight_end":24},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok((&self.gens[idx], &self.blindings[idx]))","highlight_start":1,"highlight_end":60},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl $ProverCommitted {","highlight_start":1,"highlight_end":32},{"text":"            pub fn to_bytes(&self) -> Vec<u8> {","highlight_start":1,"highlight_end":48},{"text":"                let mut bytes = vec![];","highlight_start":1,"highlight_end":40},{"text":"                for b in self.gens.as_slice() {","highlight_start":1,"highlight_end":48},{"text":"                    bytes.append(&mut b.to_bytes());","highlight_start":1,"highlight_end":53},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                bytes.append(&mut self.commitment.to_bytes());","highlight_start":1,"highlight_end":63},{"text":"                bytes","highlight_start":1,"highlight_end":22},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// This step will be done by the main protocol for which this PoK is a sub-protocol","highlight_start":1,"highlight_end":97},{"text":"            pub fn gen_challenge(&self, mut extra: Vec<u8>) -> FieldElement {","highlight_start":1,"highlight_end":78},{"text":"                let mut bytes = self.to_bytes();","highlight_start":1,"highlight_end":49},{"text":"                bytes.append(&mut extra);","highlight_start":1,"highlight_end":42},{"text":"                FieldElement::from_msg_hash(&bytes)","highlight_start":1,"highlight_end":52},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// For each secret, generate a response as self.blinding[i] - challenge*secrets[i].","highlight_start":1,"highlight_end":97},{"text":"            pub fn gen_proof(","highlight_start":1,"highlight_end":30},{"text":"                self,","highlight_start":1,"highlight_end":22},{"text":"                challenge: &FieldElement,","highlight_start":1,"highlight_end":42},{"text":"                secrets: &[FieldElement],","highlight_start":1,"highlight_end":42},{"text":"            ) -> Result<$Proof, PSError> {","highlight_start":1,"highlight_end":43},{"text":"                if secrets.len() != self.gens.len() {","highlight_start":1,"highlight_end":54},{"text":"                    return Err(PSError::UnequalNoOfBasesExponents {","highlight_start":1,"highlight_end":68},{"text":"                        bases: self.gens.len(),","highlight_start":1,"highlight_end":48},{"text":"                        exponents: secrets.len(),","highlight_start":1,"highlight_end":50},{"text":"                    });","highlight_start":1,"highlight_end":24},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                let mut responses = FieldElementVector::with_capacity(self.gens.len());","highlight_start":1,"highlight_end":88},{"text":"                for i in 0..self.gens.len() {","highlight_start":1,"highlight_end":46},{"text":"                    responses.push(&self.blindings[i] - (challenge * &secrets[i]));","highlight_start":1,"highlight_end":84},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok($Proof {","highlight_start":1,"highlight_end":28},{"text":"                    commitment: self.commitment,","highlight_start":1,"highlight_end":49},{"text":"                    responses,","highlight_start":1,"highlight_end":31},{"text":"                })","highlight_start":1,"highlight_end":19},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl $Proof {","highlight_start":1,"highlight_end":22},{"text":"            /// Verify that bases[0]^responses[0] * bases[0]^responses[0] * ... bases[i]^responses[i] * commitment^challenge == random_commitment","highlight_start":1,"highlight_end":146},{"text":"            pub fn verify(","highlight_start":1,"highlight_end":27},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                bases: &[$group_element],","highlight_start":1,"highlight_end":42},{"text":"                commitment: &$group_element,","highlight_start":1,"highlight_end":45},{"text":"                challenge: &FieldElement,","highlight_start":1,"highlight_end":42},{"text":"            ) -> Result<bool, PSError> {","highlight_start":1,"highlight_end":41},{"text":"                // bases[0]^responses[0] * bases[0]^responses[0] * ... bases[i]^responses[i] * commitment^challenge == random_commitment","highlight_start":1,"highlight_end":137},{"text":"                // =>","highlight_start":1,"highlight_end":22},{"text":"                // bases[0]^responses[0] * bases[0]^responses[0] * ... bases[i]^responses[i] * commitment^challenge * random_commitment^-1 == 1","highlight_start":1,"highlight_end":144},{"text":"                if bases.len() != self.responses.len() {","highlight_start":1,"highlight_end":57},{"text":"                    return Err(PSError::UnequalNoOfBasesExponents {","highlight_start":1,"highlight_end":68},{"text":"                        bases: bases.len(),","highlight_start":1,"highlight_end":44},{"text":"                        exponents: self.responses.len(),","highlight_start":1,"highlight_end":57},{"text":"                    });","highlight_start":1,"highlight_end":24},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                let mut points = $group_element_vec::from(bases);","highlight_start":1,"highlight_end":66},{"text":"                let mut scalars = self.responses.clone();","highlight_start":1,"highlight_end":58},{"text":"                points.push(commitment.clone());","highlight_start":1,"highlight_end":49},{"text":"                scalars.push(challenge.clone());","highlight_start":1,"highlight_end":49},{"text":"                let pr = points.multi_scalar_mul_var_time(&scalars).unwrap() - &self.commitment;","highlight_start":1,"highlight_end":97},{"text":"                Ok(pr.is_identity())","highlight_start":1,"highlight_end":37},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `Iterator` is not implemented for `&FieldElementVector`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required because of the requirements on the impl of `IntoIterator` for `&FieldElementVector`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: `&FieldElementVector` is not an iterator\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/pok_vc.rs:56:50\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m                    .multi_scalar_mul_const_time(&self.blindings)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`&FieldElementVector` is not an iterator\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/pok_sig.rs:15:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m15\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl_PoK_VC!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m16\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ProverCommittingSignatureGroup,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m17\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ProverCommittedSignatureGroup,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m18\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ProofSignatureGroup,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m19\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    SignatureGroup,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m20\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    SignatureGroupVec\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m21\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|__-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `Iterator` is not implemented for `&FieldElementVector`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required because of the requirements on the impl of `IntoIterator` for `&FieldElementVector`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_PoK_VC` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"`&FieldElementVector` is not an iterator","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/pok_vc.rs","byte_start":2046,"byte_end":2061,"line_start":56,"line_end":56,"column_start":50,"column_end":65,"is_primary":true,"text":[{"text":"                    .multi_scalar_mul_const_time(&self.blindings)","highlight_start":50,"highlight_end":65}],"label":"`&FieldElementVector` is not an iterator","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/pok_sig.rs","byte_start":755,"byte_end":889,"line_start":23,"line_end":29,"column_start":1,"column_end":3,"is_primary":false,"text":[{"text":"impl_PoK_VC!(","highlight_start":1,"highlight_end":14},{"text":"    ProverCommittingOtherGroup,","highlight_start":1,"highlight_end":32},{"text":"    ProverCommittedOtherGroup,","highlight_start":1,"highlight_end":31},{"text":"    ProofOtherGroup,","highlight_start":1,"highlight_end":21},{"text":"    OtherGroup,","highlight_start":1,"highlight_end":16},{"text":"    OtherGroupVec","highlight_start":1,"highlight_end":18},{"text":");","highlight_start":1,"highlight_end":3}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_PoK_VC!","def_site_span":{"file_name":"src/pok_vc.rs","byte_start":60,"byte_end":5692,"line_start":4,"line_end":144,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! impl_PoK_VC {","highlight_start":1,"highlight_end":27},{"text":"    ( $ProverCommitting:ident, $ProverCommitted:ident, $Proof:ident, $group_element:ident, $group_element_vec:ident ) => {","highlight_start":1,"highlight_end":123},{"text":"        /// Proof of knowledge of messages in a vector commitment.","highlight_start":1,"highlight_end":67},{"text":"        /// Commit for each message.","highlight_start":1,"highlight_end":37},{"text":"        #[derive(Clone, Debug, Serialize, Deserialize)]","highlight_start":1,"highlight_end":56},{"text":"        pub struct $ProverCommitting {","highlight_start":1,"highlight_end":39},{"text":"            gens: $group_element_vec,","highlight_start":1,"highlight_end":38},{"text":"            blindings: FieldElementVector,","highlight_start":1,"highlight_end":43},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Receive or generate challenge. Compute response and proof","highlight_start":1,"highlight_end":70},{"text":"        #[derive(Clone, Debug, Serialize, Deserialize)]","highlight_start":1,"highlight_end":56},{"text":"        pub struct $ProverCommitted {","highlight_start":1,"highlight_end":38},{"text":"            gens: $group_element_vec,","highlight_start":1,"highlight_end":38},{"text":"            blindings: FieldElementVector,","highlight_start":1,"highlight_end":43},{"text":"            commitment: $group_element,","highlight_start":1,"highlight_end":40},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        #[derive(Clone, Debug, Serialize, Deserialize)]","highlight_start":1,"highlight_end":56},{"text":"        pub struct $Proof {","highlight_start":1,"highlight_end":28},{"text":"            pub commitment: $group_element,","highlight_start":1,"highlight_end":44},{"text":"            pub responses: FieldElementVector,","highlight_start":1,"highlight_end":47},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl $ProverCommitting {","highlight_start":1,"highlight_end":33},{"text":"            pub fn new() -> Self {","highlight_start":1,"highlight_end":35},{"text":"                Self {","highlight_start":1,"highlight_end":23},{"text":"                    gens: $group_element_vec::new(0),","highlight_start":1,"highlight_end":54},{"text":"                    blindings: FieldElementVector::new(0),","highlight_start":1,"highlight_end":59},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// generate a new random blinding if None provided","highlight_start":1,"highlight_end":64},{"text":"            pub fn commit(","highlight_start":1,"highlight_end":27},{"text":"                &mut self,","highlight_start":1,"highlight_end":27},{"text":"                gen: &$group_element,","highlight_start":1,"highlight_end":38},{"text":"                blinding: Option<&FieldElement>,","highlight_start":1,"highlight_end":49},{"text":"            ) -> usize {","highlight_start":1,"highlight_end":25},{"text":"                let blinding = match blinding {","highlight_start":1,"highlight_end":48},{"text":"                    Some(b) => b.clone(),","highlight_start":1,"highlight_end":42},{"text":"                    None => FieldElement::random(),","highlight_start":1,"highlight_end":52},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let idx = self.gens.len();","highlight_start":1,"highlight_end":43},{"text":"                self.gens.push(gen.clone());","highlight_start":1,"highlight_end":45},{"text":"                self.blindings.push(blinding);","highlight_start":1,"highlight_end":47},{"text":"                idx","highlight_start":1,"highlight_end":20},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Add pairwise product of (`self.gens`, self.blindings). Uses multi-exponentiation.","highlight_start":1,"highlight_end":98},{"text":"            pub fn finish(self) -> $ProverCommitted {","highlight_start":1,"highlight_end":54},{"text":"                let commitment = self","highlight_start":1,"highlight_end":38},{"text":"                    .gens","highlight_start":1,"highlight_end":26},{"text":"                    .multi_scalar_mul_const_time(&self.blindings)","highlight_start":1,"highlight_end":66},{"text":"                    .unwrap();","highlight_start":1,"highlight_end":31},{"text":"                $ProverCommitted {","highlight_start":1,"highlight_end":35},{"text":"                    gens: self.gens,","highlight_start":1,"highlight_end":37},{"text":"                    blindings: self.blindings,","highlight_start":1,"highlight_end":47},{"text":"                    commitment,","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn get_index(","highlight_start":1,"highlight_end":30},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                idx: usize,","highlight_start":1,"highlight_end":28},{"text":"            ) -> Result<(&$group_element, &FieldElement), PSError> {","highlight_start":1,"highlight_end":69},{"text":"                if idx >= self.gens.len() {","highlight_start":1,"highlight_end":44},{"text":"                    return Err(PSError::GeneralError {","highlight_start":1,"highlight_end":55},{"text":"                        msg: format!(\"index {} greater than size {}\", idx, self.gens.len()),","highlight_start":1,"highlight_end":93},{"text":"                    });","highlight_start":1,"highlight_end":24},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok((&self.gens[idx], &self.blindings[idx]))","highlight_start":1,"highlight_end":60},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl $ProverCommitted {","highlight_start":1,"highlight_end":32},{"text":"            pub fn to_bytes(&self) -> Vec<u8> {","highlight_start":1,"highlight_end":48},{"text":"                let mut bytes = vec![];","highlight_start":1,"highlight_end":40},{"text":"                for b in self.gens.as_slice() {","highlight_start":1,"highlight_end":48},{"text":"                    bytes.append(&mut b.to_bytes());","highlight_start":1,"highlight_end":53},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                bytes.append(&mut self.commitment.to_bytes());","highlight_start":1,"highlight_end":63},{"text":"                bytes","highlight_start":1,"highlight_end":22},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// This step will be done by the main protocol for which this PoK is a sub-protocol","highlight_start":1,"highlight_end":97},{"text":"            pub fn gen_challenge(&self, mut extra: Vec<u8>) -> FieldElement {","highlight_start":1,"highlight_end":78},{"text":"                let mut bytes = self.to_bytes();","highlight_start":1,"highlight_end":49},{"text":"                bytes.append(&mut extra);","highlight_start":1,"highlight_end":42},{"text":"                FieldElement::from_msg_hash(&bytes)","highlight_start":1,"highlight_end":52},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// For each secret, generate a response as self.blinding[i] - challenge*secrets[i].","highlight_start":1,"highlight_end":97},{"text":"            pub fn gen_proof(","highlight_start":1,"highlight_end":30},{"text":"                self,","highlight_start":1,"highlight_end":22},{"text":"                challenge: &FieldElement,","highlight_start":1,"highlight_end":42},{"text":"                secrets: &[FieldElement],","highlight_start":1,"highlight_end":42},{"text":"            ) -> Result<$Proof, PSError> {","highlight_start":1,"highlight_end":43},{"text":"                if secrets.len() != self.gens.len() {","highlight_start":1,"highlight_end":54},{"text":"                    return Err(PSError::UnequalNoOfBasesExponents {","highlight_start":1,"highlight_end":68},{"text":"                        bases: self.gens.len(),","highlight_start":1,"highlight_end":48},{"text":"                        exponents: secrets.len(),","highlight_start":1,"highlight_end":50},{"text":"                    });","highlight_start":1,"highlight_end":24},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                let mut responses = FieldElementVector::with_capacity(self.gens.len());","highlight_start":1,"highlight_end":88},{"text":"                for i in 0..self.gens.len() {","highlight_start":1,"highlight_end":46},{"text":"                    responses.push(&self.blindings[i] - (challenge * &secrets[i]));","highlight_start":1,"highlight_end":84},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok($Proof {","highlight_start":1,"highlight_end":28},{"text":"                    commitment: self.commitment,","highlight_start":1,"highlight_end":49},{"text":"                    responses,","highlight_start":1,"highlight_end":31},{"text":"                })","highlight_start":1,"highlight_end":19},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl $Proof {","highlight_start":1,"highlight_end":22},{"text":"            /// Verify that bases[0]^responses[0] * bases[0]^responses[0] * ... bases[i]^responses[i] * commitment^challenge == random_commitment","highlight_start":1,"highlight_end":146},{"text":"            pub fn verify(","highlight_start":1,"highlight_end":27},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                bases: &[$group_element],","highlight_start":1,"highlight_end":42},{"text":"                commitment: &$group_element,","highlight_start":1,"highlight_end":45},{"text":"                challenge: &FieldElement,","highlight_start":1,"highlight_end":42},{"text":"            ) -> Result<bool, PSError> {","highlight_start":1,"highlight_end":41},{"text":"                // bases[0]^responses[0] * bases[0]^responses[0] * ... bases[i]^responses[i] * commitment^challenge == random_commitment","highlight_start":1,"highlight_end":137},{"text":"                // =>","highlight_start":1,"highlight_end":22},{"text":"                // bases[0]^responses[0] * bases[0]^responses[0] * ... bases[i]^responses[i] * commitment^challenge * random_commitment^-1 == 1","highlight_start":1,"highlight_end":144},{"text":"                if bases.len() != self.responses.len() {","highlight_start":1,"highlight_end":57},{"text":"                    return Err(PSError::UnequalNoOfBasesExponents {","highlight_start":1,"highlight_end":68},{"text":"                        bases: bases.len(),","highlight_start":1,"highlight_end":44},{"text":"                        exponents: self.responses.len(),","highlight_start":1,"highlight_end":57},{"text":"                    });","highlight_start":1,"highlight_end":24},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                let mut points = $group_element_vec::from(bases);","highlight_start":1,"highlight_end":66},{"text":"                let mut scalars = self.responses.clone();","highlight_start":1,"highlight_end":58},{"text":"                points.push(commitment.clone());","highlight_start":1,"highlight_end":49},{"text":"                scalars.push(challenge.clone());","highlight_start":1,"highlight_end":49},{"text":"                let pr = points.multi_scalar_mul_var_time(&scalars).unwrap() - &self.commitment;","highlight_start":1,"highlight_end":97},{"text":"                Ok(pr.is_identity())","highlight_start":1,"highlight_end":37},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `Iterator` is not implemented for `&FieldElementVector`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required because of the requirements on the impl of `IntoIterator` for `&FieldElementVector`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: `&FieldElementVector` is not an iterator\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/pok_vc.rs:56:50\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m                    .multi_scalar_mul_const_time(&self.blindings)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`&FieldElementVector` is not an iterator\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/pok_sig.rs:23:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m23\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl_PoK_VC!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m24\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ProverCommittingOtherGroup,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m25\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ProverCommittedOtherGroup,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m26\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ProofOtherGroup,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m27\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    OtherGroup,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m28\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    OtherGroupVec\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m29\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|__-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `Iterator` is not implemented for `&FieldElementVector`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required because of the requirements on the impl of `IntoIterator` for `&FieldElementVector`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_PoK_VC` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"`&FieldElementVector` is not an iterator","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/pok_vc.rs","byte_start":5584,"byte_end":5592,"line_start":139,"line_end":139,"column_start":59,"column_end":67,"is_primary":true,"text":[{"text":"                let pr = points.multi_scalar_mul_var_time(&scalars).unwrap() - &self.commitment;","highlight_start":59,"highlight_end":67}],"label":"`&FieldElementVector` is not an iterator","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/pok_sig.rs","byte_start":599,"byte_end":753,"line_start":15,"line_end":21,"column_start":1,"column_end":3,"is_primary":false,"text":[{"text":"impl_PoK_VC!(","highlight_start":1,"highlight_end":14},{"text":"    ProverCommittingSignatureGroup,","highlight_start":1,"highlight_end":36},{"text":"    ProverCommittedSignatureGroup,","highlight_start":1,"highlight_end":35},{"text":"    ProofSignatureGroup,","highlight_start":1,"highlight_end":25},{"text":"    SignatureGroup,","highlight_start":1,"highlight_end":20},{"text":"    SignatureGroupVec","highlight_start":1,"highlight_end":22},{"text":");","highlight_start":1,"highlight_end":3}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_PoK_VC!","def_site_span":{"file_name":"src/pok_vc.rs","byte_start":60,"byte_end":5692,"line_start":4,"line_end":144,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! impl_PoK_VC {","highlight_start":1,"highlight_end":27},{"text":"    ( $ProverCommitting:ident, $ProverCommitted:ident, $Proof:ident, $group_element:ident, $group_element_vec:ident ) => {","highlight_start":1,"highlight_end":123},{"text":"        /// Proof of knowledge of messages in a vector commitment.","highlight_start":1,"highlight_end":67},{"text":"        /// Commit for each message.","highlight_start":1,"highlight_end":37},{"text":"        #[derive(Clone, Debug, Serialize, Deserialize)]","highlight_start":1,"highlight_end":56},{"text":"        pub struct $ProverCommitting {","highlight_start":1,"highlight_end":39},{"text":"            gens: $group_element_vec,","highlight_start":1,"highlight_end":38},{"text":"            blindings: FieldElementVector,","highlight_start":1,"highlight_end":43},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Receive or generate challenge. Compute response and proof","highlight_start":1,"highlight_end":70},{"text":"        #[derive(Clone, Debug, Serialize, Deserialize)]","highlight_start":1,"highlight_end":56},{"text":"        pub struct $ProverCommitted {","highlight_start":1,"highlight_end":38},{"text":"            gens: $group_element_vec,","highlight_start":1,"highlight_end":38},{"text":"            blindings: FieldElementVector,","highlight_start":1,"highlight_end":43},{"text":"            commitment: $group_element,","highlight_start":1,"highlight_end":40},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        #[derive(Clone, Debug, Serialize, Deserialize)]","highlight_start":1,"highlight_end":56},{"text":"        pub struct $Proof {","highlight_start":1,"highlight_end":28},{"text":"            pub commitment: $group_element,","highlight_start":1,"highlight_end":44},{"text":"            pub responses: FieldElementVector,","highlight_start":1,"highlight_end":47},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl $ProverCommitting {","highlight_start":1,"highlight_end":33},{"text":"            pub fn new() -> Self {","highlight_start":1,"highlight_end":35},{"text":"                Self {","highlight_start":1,"highlight_end":23},{"text":"                    gens: $group_element_vec::new(0),","highlight_start":1,"highlight_end":54},{"text":"                    blindings: FieldElementVector::new(0),","highlight_start":1,"highlight_end":59},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// generate a new random blinding if None provided","highlight_start":1,"highlight_end":64},{"text":"            pub fn commit(","highlight_start":1,"highlight_end":27},{"text":"                &mut self,","highlight_start":1,"highlight_end":27},{"text":"                gen: &$group_element,","highlight_start":1,"highlight_end":38},{"text":"                blinding: Option<&FieldElement>,","highlight_start":1,"highlight_end":49},{"text":"            ) -> usize {","highlight_start":1,"highlight_end":25},{"text":"                let blinding = match blinding {","highlight_start":1,"highlight_end":48},{"text":"                    Some(b) => b.clone(),","highlight_start":1,"highlight_end":42},{"text":"                    None => FieldElement::random(),","highlight_start":1,"highlight_end":52},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let idx = self.gens.len();","highlight_start":1,"highlight_end":43},{"text":"                self.gens.push(gen.clone());","highlight_start":1,"highlight_end":45},{"text":"                self.blindings.push(blinding);","highlight_start":1,"highlight_end":47},{"text":"                idx","highlight_start":1,"highlight_end":20},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Add pairwise product of (`self.gens`, self.blindings). Uses multi-exponentiation.","highlight_start":1,"highlight_end":98},{"text":"            pub fn finish(self) -> $ProverCommitted {","highlight_start":1,"highlight_end":54},{"text":"                let commitment = self","highlight_start":1,"highlight_end":38},{"text":"                    .gens","highlight_start":1,"highlight_end":26},{"text":"                    .multi_scalar_mul_const_time(&self.blindings)","highlight_start":1,"highlight_end":66},{"text":"                    .unwrap();","highlight_start":1,"highlight_end":31},{"text":"                $ProverCommitted {","highlight_start":1,"highlight_end":35},{"text":"                    gens: self.gens,","highlight_start":1,"highlight_end":37},{"text":"                    blindings: self.blindings,","highlight_start":1,"highlight_end":47},{"text":"                    commitment,","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn get_index(","highlight_start":1,"highlight_end":30},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                idx: usize,","highlight_start":1,"highlight_end":28},{"text":"            ) -> Result<(&$group_element, &FieldElement), PSError> {","highlight_start":1,"highlight_end":69},{"text":"                if idx >= self.gens.len() {","highlight_start":1,"highlight_end":44},{"text":"                    return Err(PSError::GeneralError {","highlight_start":1,"highlight_end":55},{"text":"                        msg: format!(\"index {} greater than size {}\", idx, self.gens.len()),","highlight_start":1,"highlight_end":93},{"text":"                    });","highlight_start":1,"highlight_end":24},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok((&self.gens[idx], &self.blindings[idx]))","highlight_start":1,"highlight_end":60},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl $ProverCommitted {","highlight_start":1,"highlight_end":32},{"text":"            pub fn to_bytes(&self) -> Vec<u8> {","highlight_start":1,"highlight_end":48},{"text":"                let mut bytes = vec![];","highlight_start":1,"highlight_end":40},{"text":"                for b in self.gens.as_slice() {","highlight_start":1,"highlight_end":48},{"text":"                    bytes.append(&mut b.to_bytes());","highlight_start":1,"highlight_end":53},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                bytes.append(&mut self.commitment.to_bytes());","highlight_start":1,"highlight_end":63},{"text":"                bytes","highlight_start":1,"highlight_end":22},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// This step will be done by the main protocol for which this PoK is a sub-protocol","highlight_start":1,"highlight_end":97},{"text":"            pub fn gen_challenge(&self, mut extra: Vec<u8>) -> FieldElement {","highlight_start":1,"highlight_end":78},{"text":"                let mut bytes = self.to_bytes();","highlight_start":1,"highlight_end":49},{"text":"                bytes.append(&mut extra);","highlight_start":1,"highlight_end":42},{"text":"                FieldElement::from_msg_hash(&bytes)","highlight_start":1,"highlight_end":52},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// For each secret, generate a response as self.blinding[i] - challenge*secrets[i].","highlight_start":1,"highlight_end":97},{"text":"            pub fn gen_proof(","highlight_start":1,"highlight_end":30},{"text":"                self,","highlight_start":1,"highlight_end":22},{"text":"                challenge: &FieldElement,","highlight_start":1,"highlight_end":42},{"text":"                secrets: &[FieldElement],","highlight_start":1,"highlight_end":42},{"text":"            ) -> Result<$Proof, PSError> {","highlight_start":1,"highlight_end":43},{"text":"                if secrets.len() != self.gens.len() {","highlight_start":1,"highlight_end":54},{"text":"                    return Err(PSError::UnequalNoOfBasesExponents {","highlight_start":1,"highlight_end":68},{"text":"                        bases: self.gens.len(),","highlight_start":1,"highlight_end":48},{"text":"                        exponents: secrets.len(),","highlight_start":1,"highlight_end":50},{"text":"                    });","highlight_start":1,"highlight_end":24},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                let mut responses = FieldElementVector::with_capacity(self.gens.len());","highlight_start":1,"highlight_end":88},{"text":"                for i in 0..self.gens.len() {","highlight_start":1,"highlight_end":46},{"text":"                    responses.push(&self.blindings[i] - (challenge * &secrets[i]));","highlight_start":1,"highlight_end":84},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok($Proof {","highlight_start":1,"highlight_end":28},{"text":"                    commitment: self.commitment,","highlight_start":1,"highlight_end":49},{"text":"                    responses,","highlight_start":1,"highlight_end":31},{"text":"                })","highlight_start":1,"highlight_end":19},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl $Proof {","highlight_start":1,"highlight_end":22},{"text":"            /// Verify that bases[0]^responses[0] * bases[0]^responses[0] * ... bases[i]^responses[i] * commitment^challenge == random_commitment","highlight_start":1,"highlight_end":146},{"text":"            pub fn verify(","highlight_start":1,"highlight_end":27},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                bases: &[$group_element],","highlight_start":1,"highlight_end":42},{"text":"                commitment: &$group_element,","highlight_start":1,"highlight_end":45},{"text":"                challenge: &FieldElement,","highlight_start":1,"highlight_end":42},{"text":"            ) -> Result<bool, PSError> {","highlight_start":1,"highlight_end":41},{"text":"                // bases[0]^responses[0] * bases[0]^responses[0] * ... bases[i]^responses[i] * commitment^challenge == random_commitment","highlight_start":1,"highlight_end":137},{"text":"                // =>","highlight_start":1,"highlight_end":22},{"text":"                // bases[0]^responses[0] * bases[0]^responses[0] * ... bases[i]^responses[i] * commitment^challenge * random_commitment^-1 == 1","highlight_start":1,"highlight_end":144},{"text":"                if bases.len() != self.responses.len() {","highlight_start":1,"highlight_end":57},{"text":"                    return Err(PSError::UnequalNoOfBasesExponents {","highlight_start":1,"highlight_end":68},{"text":"                        bases: bases.len(),","highlight_start":1,"highlight_end":44},{"text":"                        exponents: self.responses.len(),","highlight_start":1,"highlight_end":57},{"text":"                    });","highlight_start":1,"highlight_end":24},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                let mut points = $group_element_vec::from(bases);","highlight_start":1,"highlight_end":66},{"text":"                let mut scalars = self.responses.clone();","highlight_start":1,"highlight_end":58},{"text":"                points.push(commitment.clone());","highlight_start":1,"highlight_end":49},{"text":"                scalars.push(challenge.clone());","highlight_start":1,"highlight_end":49},{"text":"                let pr = points.multi_scalar_mul_var_time(&scalars).unwrap() - &self.commitment;","highlight_start":1,"highlight_end":97},{"text":"                Ok(pr.is_identity())","highlight_start":1,"highlight_end":37},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `Iterator` is not implemented for `&FieldElementVector`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required because of the requirements on the impl of `IntoIterator` for `&FieldElementVector`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: `&FieldElementVector` is not an iterator\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/pok_vc.rs:139:59\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m139\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m                let pr = points.multi_scalar_mul_var_time(&scalars).unwrap() - &self.commitment;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`&FieldElementVector` is not an iterator\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/pok_sig.rs:15:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m15\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl_PoK_VC!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m16\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ProverCommittingSignatureGroup,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m17\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ProverCommittedSignatureGroup,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m18\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ProofSignatureGroup,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m19\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    SignatureGroup,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m20\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    SignatureGroupVec\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m21\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|__-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `Iterator` is not implemented for `&FieldElementVector`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required because of the requirements on the impl of `IntoIterator` for `&FieldElementVector`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_PoK_VC` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"`&FieldElementVector` is not an iterator","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/pok_vc.rs","byte_start":5584,"byte_end":5592,"line_start":139,"line_end":139,"column_start":59,"column_end":67,"is_primary":true,"text":[{"text":"                let pr = points.multi_scalar_mul_var_time(&scalars).unwrap() - &self.commitment;","highlight_start":59,"highlight_end":67}],"label":"`&FieldElementVector` is not an iterator","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/pok_sig.rs","byte_start":755,"byte_end":889,"line_start":23,"line_end":29,"column_start":1,"column_end":3,"is_primary":false,"text":[{"text":"impl_PoK_VC!(","highlight_start":1,"highlight_end":14},{"text":"    ProverCommittingOtherGroup,","highlight_start":1,"highlight_end":32},{"text":"    ProverCommittedOtherGroup,","highlight_start":1,"highlight_end":31},{"text":"    ProofOtherGroup,","highlight_start":1,"highlight_end":21},{"text":"    OtherGroup,","highlight_start":1,"highlight_end":16},{"text":"    OtherGroupVec","highlight_start":1,"highlight_end":18},{"text":");","highlight_start":1,"highlight_end":3}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_PoK_VC!","def_site_span":{"file_name":"src/pok_vc.rs","byte_start":60,"byte_end":5692,"line_start":4,"line_end":144,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! impl_PoK_VC {","highlight_start":1,"highlight_end":27},{"text":"    ( $ProverCommitting:ident, $ProverCommitted:ident, $Proof:ident, $group_element:ident, $group_element_vec:ident ) => {","highlight_start":1,"highlight_end":123},{"text":"        /// Proof of knowledge of messages in a vector commitment.","highlight_start":1,"highlight_end":67},{"text":"        /// Commit for each message.","highlight_start":1,"highlight_end":37},{"text":"        #[derive(Clone, Debug, Serialize, Deserialize)]","highlight_start":1,"highlight_end":56},{"text":"        pub struct $ProverCommitting {","highlight_start":1,"highlight_end":39},{"text":"            gens: $group_element_vec,","highlight_start":1,"highlight_end":38},{"text":"            blindings: FieldElementVector,","highlight_start":1,"highlight_end":43},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Receive or generate challenge. Compute response and proof","highlight_start":1,"highlight_end":70},{"text":"        #[derive(Clone, Debug, Serialize, Deserialize)]","highlight_start":1,"highlight_end":56},{"text":"        pub struct $ProverCommitted {","highlight_start":1,"highlight_end":38},{"text":"            gens: $group_element_vec,","highlight_start":1,"highlight_end":38},{"text":"            blindings: FieldElementVector,","highlight_start":1,"highlight_end":43},{"text":"            commitment: $group_element,","highlight_start":1,"highlight_end":40},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        #[derive(Clone, Debug, Serialize, Deserialize)]","highlight_start":1,"highlight_end":56},{"text":"        pub struct $Proof {","highlight_start":1,"highlight_end":28},{"text":"            pub commitment: $group_element,","highlight_start":1,"highlight_end":44},{"text":"            pub responses: FieldElementVector,","highlight_start":1,"highlight_end":47},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl $ProverCommitting {","highlight_start":1,"highlight_end":33},{"text":"            pub fn new() -> Self {","highlight_start":1,"highlight_end":35},{"text":"                Self {","highlight_start":1,"highlight_end":23},{"text":"                    gens: $group_element_vec::new(0),","highlight_start":1,"highlight_end":54},{"text":"                    blindings: FieldElementVector::new(0),","highlight_start":1,"highlight_end":59},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// generate a new random blinding if None provided","highlight_start":1,"highlight_end":64},{"text":"            pub fn commit(","highlight_start":1,"highlight_end":27},{"text":"                &mut self,","highlight_start":1,"highlight_end":27},{"text":"                gen: &$group_element,","highlight_start":1,"highlight_end":38},{"text":"                blinding: Option<&FieldElement>,","highlight_start":1,"highlight_end":49},{"text":"            ) -> usize {","highlight_start":1,"highlight_end":25},{"text":"                let blinding = match blinding {","highlight_start":1,"highlight_end":48},{"text":"                    Some(b) => b.clone(),","highlight_start":1,"highlight_end":42},{"text":"                    None => FieldElement::random(),","highlight_start":1,"highlight_end":52},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let idx = self.gens.len();","highlight_start":1,"highlight_end":43},{"text":"                self.gens.push(gen.clone());","highlight_start":1,"highlight_end":45},{"text":"                self.blindings.push(blinding);","highlight_start":1,"highlight_end":47},{"text":"                idx","highlight_start":1,"highlight_end":20},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Add pairwise product of (`self.gens`, self.blindings). Uses multi-exponentiation.","highlight_start":1,"highlight_end":98},{"text":"            pub fn finish(self) -> $ProverCommitted {","highlight_start":1,"highlight_end":54},{"text":"                let commitment = self","highlight_start":1,"highlight_end":38},{"text":"                    .gens","highlight_start":1,"highlight_end":26},{"text":"                    .multi_scalar_mul_const_time(&self.blindings)","highlight_start":1,"highlight_end":66},{"text":"                    .unwrap();","highlight_start":1,"highlight_end":31},{"text":"                $ProverCommitted {","highlight_start":1,"highlight_end":35},{"text":"                    gens: self.gens,","highlight_start":1,"highlight_end":37},{"text":"                    blindings: self.blindings,","highlight_start":1,"highlight_end":47},{"text":"                    commitment,","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn get_index(","highlight_start":1,"highlight_end":30},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                idx: usize,","highlight_start":1,"highlight_end":28},{"text":"            ) -> Result<(&$group_element, &FieldElement), PSError> {","highlight_start":1,"highlight_end":69},{"text":"                if idx >= self.gens.len() {","highlight_start":1,"highlight_end":44},{"text":"                    return Err(PSError::GeneralError {","highlight_start":1,"highlight_end":55},{"text":"                        msg: format!(\"index {} greater than size {}\", idx, self.gens.len()),","highlight_start":1,"highlight_end":93},{"text":"                    });","highlight_start":1,"highlight_end":24},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok((&self.gens[idx], &self.blindings[idx]))","highlight_start":1,"highlight_end":60},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl $ProverCommitted {","highlight_start":1,"highlight_end":32},{"text":"            pub fn to_bytes(&self) -> Vec<u8> {","highlight_start":1,"highlight_end":48},{"text":"                let mut bytes = vec![];","highlight_start":1,"highlight_end":40},{"text":"                for b in self.gens.as_slice() {","highlight_start":1,"highlight_end":48},{"text":"                    bytes.append(&mut b.to_bytes());","highlight_start":1,"highlight_end":53},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                bytes.append(&mut self.commitment.to_bytes());","highlight_start":1,"highlight_end":63},{"text":"                bytes","highlight_start":1,"highlight_end":22},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// This step will be done by the main protocol for which this PoK is a sub-protocol","highlight_start":1,"highlight_end":97},{"text":"            pub fn gen_challenge(&self, mut extra: Vec<u8>) -> FieldElement {","highlight_start":1,"highlight_end":78},{"text":"                let mut bytes = self.to_bytes();","highlight_start":1,"highlight_end":49},{"text":"                bytes.append(&mut extra);","highlight_start":1,"highlight_end":42},{"text":"                FieldElement::from_msg_hash(&bytes)","highlight_start":1,"highlight_end":52},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// For each secret, generate a response as self.blinding[i] - challenge*secrets[i].","highlight_start":1,"highlight_end":97},{"text":"            pub fn gen_proof(","highlight_start":1,"highlight_end":30},{"text":"                self,","highlight_start":1,"highlight_end":22},{"text":"                challenge: &FieldElement,","highlight_start":1,"highlight_end":42},{"text":"                secrets: &[FieldElement],","highlight_start":1,"highlight_end":42},{"text":"            ) -> Result<$Proof, PSError> {","highlight_start":1,"highlight_end":43},{"text":"                if secrets.len() != self.gens.len() {","highlight_start":1,"highlight_end":54},{"text":"                    return Err(PSError::UnequalNoOfBasesExponents {","highlight_start":1,"highlight_end":68},{"text":"                        bases: self.gens.len(),","highlight_start":1,"highlight_end":48},{"text":"                        exponents: secrets.len(),","highlight_start":1,"highlight_end":50},{"text":"                    });","highlight_start":1,"highlight_end":24},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                let mut responses = FieldElementVector::with_capacity(self.gens.len());","highlight_start":1,"highlight_end":88},{"text":"                for i in 0..self.gens.len() {","highlight_start":1,"highlight_end":46},{"text":"                    responses.push(&self.blindings[i] - (challenge * &secrets[i]));","highlight_start":1,"highlight_end":84},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok($Proof {","highlight_start":1,"highlight_end":28},{"text":"                    commitment: self.commitment,","highlight_start":1,"highlight_end":49},{"text":"                    responses,","highlight_start":1,"highlight_end":31},{"text":"                })","highlight_start":1,"highlight_end":19},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl $Proof {","highlight_start":1,"highlight_end":22},{"text":"            /// Verify that bases[0]^responses[0] * bases[0]^responses[0] * ... bases[i]^responses[i] * commitment^challenge == random_commitment","highlight_start":1,"highlight_end":146},{"text":"            pub fn verify(","highlight_start":1,"highlight_end":27},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                bases: &[$group_element],","highlight_start":1,"highlight_end":42},{"text":"                commitment: &$group_element,","highlight_start":1,"highlight_end":45},{"text":"                challenge: &FieldElement,","highlight_start":1,"highlight_end":42},{"text":"            ) -> Result<bool, PSError> {","highlight_start":1,"highlight_end":41},{"text":"                // bases[0]^responses[0] * bases[0]^responses[0] * ... bases[i]^responses[i] * commitment^challenge == random_commitment","highlight_start":1,"highlight_end":137},{"text":"                // =>","highlight_start":1,"highlight_end":22},{"text":"                // bases[0]^responses[0] * bases[0]^responses[0] * ... bases[i]^responses[i] * commitment^challenge * random_commitment^-1 == 1","highlight_start":1,"highlight_end":144},{"text":"                if bases.len() != self.responses.len() {","highlight_start":1,"highlight_end":57},{"text":"                    return Err(PSError::UnequalNoOfBasesExponents {","highlight_start":1,"highlight_end":68},{"text":"                        bases: bases.len(),","highlight_start":1,"highlight_end":44},{"text":"                        exponents: self.responses.len(),","highlight_start":1,"highlight_end":57},{"text":"                    });","highlight_start":1,"highlight_end":24},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                let mut points = $group_element_vec::from(bases);","highlight_start":1,"highlight_end":66},{"text":"                let mut scalars = self.responses.clone();","highlight_start":1,"highlight_end":58},{"text":"                points.push(commitment.clone());","highlight_start":1,"highlight_end":49},{"text":"                scalars.push(challenge.clone());","highlight_start":1,"highlight_end":49},{"text":"                let pr = points.multi_scalar_mul_var_time(&scalars).unwrap() - &self.commitment;","highlight_start":1,"highlight_end":97},{"text":"                Ok(pr.is_identity())","highlight_start":1,"highlight_end":37},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `Iterator` is not implemented for `&FieldElementVector`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required because of the requirements on the impl of `IntoIterator` for `&FieldElementVector`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: `&FieldElementVector` is not an iterator\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/pok_vc.rs:139:59\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m139\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m                let pr = points.multi_scalar_mul_var_time(&scalars).unwrap() - &self.commitment;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`&FieldElementVector` is not an iterator\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/pok_sig.rs:23:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m23\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl_PoK_VC!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m24\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ProverCommittingOtherGroup,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m25\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ProverCommittedOtherGroup,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m26\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ProofOtherGroup,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m27\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    OtherGroup,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m28\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    OtherGroupVec\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m29\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|__-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `Iterator` is not implemented for `&FieldElementVector`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required because of the requirements on the impl of `IntoIterator` for `&FieldElementVector`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_PoK_VC` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"`&FieldElementVector` is not an iterator","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/pok_sig.rs","byte_start":3979,"byte_end":3989,"line_start":95,"line_end":95,"column_start":51,"column_end":61,"is_primary":true,"text":[{"text":"        let J = bases.multi_scalar_mul_const_time(&exponents).unwrap();","highlight_start":51,"highlight_end":61}],"label":"`&FieldElementVector` is not an iterator","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `Iterator` is not implemented for `&FieldElementVector`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required because of the requirements on the impl of `IntoIterator` for `&FieldElementVector`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: `&FieldElementVector` is not an iterator\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/pok_sig.rs:95:51\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m95\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let J = bases.multi_scalar_mul_const_time(&exponents).unwrap();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`&FieldElementVector` is not an iterator\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `Iterator` is not implemented for `&FieldElementVector`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required because of the requirements on the impl of `IntoIterator` for `&FieldElementVector`\u001b[0m\n\n"}
{"message":"`&FieldElementVector` is not an iterator","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/pok_sig.rs","byte_start":6614,"byte_end":6616,"line_start":172,"line_end":172,"column_start":46,"column_end":48,"is_primary":true,"text":[{"text":"            j += b.multi_scalar_mul_var_time(&e).unwrap();","highlight_start":46,"highlight_end":48}],"label":"`&FieldElementVector` is not an iterator","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `Iterator` is not implemented for `&FieldElementVector`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required because of the requirements on the impl of `IntoIterator` for `&FieldElementVector`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: `&FieldElementVector` is not an iterator\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/pok_sig.rs:172:46\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m172\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            j += b.multi_scalar_mul_var_time(&e).unwrap();\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`&FieldElementVector` is not an iterator\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `Iterator` is not implemented for `&FieldElementVector`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required because of the requirements on the impl of `IntoIterator` for `&FieldElementVector`\u001b[0m\n\n"}
{"message":"`&FieldElementVector` is not an iterator","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/signature.rs","byte_start":2622,"byte_end":2630,"line_start":62,"line_end":62,"column_start":70,"column_end":78,"is_primary":true,"text":[{"text":"        let pr = &verkey.X_tilde + &points.multi_scalar_mul_var_time(&scalars).unwrap();","highlight_start":70,"highlight_end":78}],"label":"`&FieldElementVector` is not an iterator","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `Iterator` is not implemented for `&FieldElementVector`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required because of the requirements on the impl of `IntoIterator` for `&FieldElementVector`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: `&FieldElementVector` is not an iterator\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/signature.rs:62:70\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m62\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let pr = &verkey.X_tilde + &points.multi_scalar_mul_var_time(&scalars).unwrap();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`&FieldElementVector` is not an iterator\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `Iterator` is not implemented for `&FieldElementVector`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required because of the requirements on the impl of `IntoIterator` for `&FieldElementVector`\u001b[0m\n\n"}
{"message":"`&FieldElementVector` is not an iterator","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/signature.rs","byte_start":4831,"byte_end":4839,"line_start":117,"line_end":117,"column_start":75,"column_end":83,"is_primary":true,"text":[{"text":"        let mut sigma_2 = &sigkey.X + &points.multi_scalar_mul_const_time(&scalars).unwrap();","highlight_start":75,"highlight_end":83}],"label":"`&FieldElementVector` is not an iterator","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `Iterator` is not implemented for `&FieldElementVector`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required because of the requirements on the impl of `IntoIterator` for `&FieldElementVector`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: `&FieldElementVector` is not an iterator\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/signature.rs:117:75\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m117\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut sigma_2 = &sigkey.X + &points.multi_scalar_mul_const_time(&scalars).unwrap();\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`&FieldElementVector` is not an iterator\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `Iterator` is not implemented for `&FieldElementVector`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required because of the requirements on the impl of `IntoIterator` for `&FieldElementVector`\u001b[0m\n\n"}
{"message":"aborting due to 8 previous errors; 5 warnings emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 8 previous errors; 5 warnings emitted\u001b[0m\n\n"}
{"message":"For more information about this error, try `rustc --explain E0277`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about this error, try `rustc --explain E0277`.\u001b[0m\n"}
